{"name":"Packer-ng-plugin","tagline":"下一代Android打包工具，1000个渠道包只需要5秒钟","body":"下一代Android渠道打包工具\r\n========\r\n\r\n## 最新版本\r\n\r\n- **v1.0.4 - 2016.01.19** - 完善获取APK路径的方法,增加MarketInfo\r\n- **v1.0.3 - 2016.01.14** - 增加缓存，新增ResUtils，更有好的错误提示\r\n- **v1.0.2 - 2015.12.04** - 兼容productFlavors，完善异常处理\r\n- **v1.0.1 - 2015.12.01** - 如果没有读取到渠道，默认返回空字符串\r\n- **v1.0.0 - 2015.11.30** - 增加Java和Python打包脚本，增加文档\r\n- **v0.9.9 - 2015.11.26** - 测试版发布，支持全新的极速打包方式 \r\n\r\n## 项目介绍\r\n\r\n[**packer-ng-plugin**](https://github.com/mcxiaoke/packer-ng-plugin) 是下一代Android渠道打包工具Gradle插件，支持极速打包，**1000**个渠道包只需要**5**秒钟，速度是 [**gradle-packer-plugin**](https://github.com/mcxiaoke/gradle-packer-plugin) 的**1000**倍以上，可方便的用于CI系统集成，支持自定义输出目录和最终APK文件名，依赖包： `com.mcxiaoke.gradle:packer-ng:1.0.+` 简短名：`packer`，可以在项目的 `build.gradle` 中指定使用，还提供了命令行独立使用的Java和Python脚本。实现原理见本文末尾。\r\n\r\n## 使用指南\r\n\r\n[`Maven Central`](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22packer-ng%22)\r\n\r\n### 修改项目根目录的 `build.gradle`\r\n\r\n```groovy\r\n\r\nbuildscript {\r\n\t......\r\n\tdependencies{\r\n\t// add packer-ng\r\n\t\tclasspath 'com.mcxiaoke.gradle:packer-ng:1.0.4'\r\n\t}\r\n}  \r\n```\r\n\r\n### 修改Android模块的 `build.gradle`\r\n\r\n```groovy\r\napply plugin: 'packer' \r\n\r\ndependencies {\r\n\t// add packer-helper\r\n\tcompile 'com.mcxiaoke.gradle:packer-helper:1.0.4'\r\n} \r\n```\r\n\r\n**注意：`packer-ng` 和 `packer-helper` 的版本号需要保持一致**\r\n\r\n### Java代码中获取当前渠道\r\n\r\n提示：`PackerNg.getMarket(Context)`内部缓存了结果，不会重复解析APK文件\r\n\r\n```java\r\n\r\n// 如果没有使用PackerNg打包添加渠道，默认返回的是\"\"\r\n// com.mcxiaoke.packer.helper.PackerNg\r\nfinal String market = PackerNg.getMarket(Context)\r\n// 或者使用 PackerNg.getMarket(Context,defaultValue)\r\n// 之后就可以使用了，比如友盟可以这样设置\r\nAnalyticsConfig.setChannel(market)\r\n\r\n```\r\n\r\n### 渠道打包脚本\r\n\r\n可以通过两种方式指定 `market` 属性，根据需要选用：\r\n\r\n- 打包时命令行使用 `-Pmarket= yourMarketFilePath` 指定属性\r\n- 在 `gradle.properties` 里加入 `market=yourMarketFilePath`\r\n\r\nmarket是你的渠道名列表文件，market文件是基于**项目根目录**的 `相对路径` ，假设你的项目位于 `~/github/myapp` 你的market文件位于 `~/github/myapp/config/markets.txt` 那么参数应该是 `-Pmarket=config/markets.txt`，一般建议直接放在项目根目录，如果market文件参数错误或者文件不存在会抛出异常。\r\n\r\n渠道名列表文件是纯文本文件，每行一个渠道号，列表解析的时候会自动忽略空白行和格式不规范的行，请注意看命令行输出，渠道名和注释之间用 `#` 号分割开，可以没有注释，示例：\r\n\r\n```\r\n Google_Play#play store market\r\n Gradle_Test#test\r\n SomeMarket#some market\r\n HelloWorld\r\n```\r\n\r\n渠道打包的Gradle命令行参数格式示例（在项目根目录执行）：  \r\n\r\n```shell\r\n./gradlew -Pmarket=markets.txt clean apkRelease\r\n``` \r\n\r\n打包完成后你可以在 `${项目根目录}/build/archives/` 目录找到最终的渠道包。\r\n\r\n#### 任务说明\r\n\r\n渠道打包的Gradle Task名字是 `apk${buildType}` buildType一般是release，也可以是你自己指定的beta或者someOtherType，使用时首字母需要大写，例如release的渠道包任务名是 `apkRelease`，beta的渠道包任务名是 `apkBeta`，其它的以此类推。\r\n\r\n#### 注意事项\r\n\r\n**不支持`productFlavors`中定义的条件编译变量，不支持修改AndroidManifest**\r\n\r\n如果你的项目有多个`productFlavors`，默认只会用第一个`flavor`生成的APK文件作为打包工具的输入参数，忽略其它`flavor`生成的apk，代码里用的是 `ariant.outputs[0].outputFile`。如果你想指定使用某个flavor来生成渠道包，可以用 `apkFlavor1Release`，`apkFlavor2Beta`这样的名字，示例（假设flavor名字是Intel）：\r\n\r\n```shell\r\n./gradlew -Pmarket=markets.txt clean apkIntelRelease\r\n``` \r\n\r\n### 插件配置说明（可选） \r\n\r\n```groovy \r\npacker {\r\n    // 指定渠道打包输出目录\r\n    // archiveOutput = file(new File(project.rootProject.buildDir.path, \"archives\"))\r\n    // 指定渠道打包输出文件名格式\r\n    // 默认是 `${appPkg}-${flavorName}-${buildType}-v${versionName}-${versionCode}`\r\n    // archiveNameFormat = ''\r\n}\r\n```\r\n\r\n举例：假如你的App包名是  `com.your.company` ，渠道名是 `Google_Play` ，`buildType` 是 `release` ，`versionName` 是 `2.1.15` ，`versionCode` 是 `200115` ，那么生成的APK的文件名是 `com.your.company-Google_Player-release-2.1.15-20015.apk`   \r\n\r\n* **archiveOutput**  指定渠道打包输出的APK存放目录，默认位于`${项目根目录}/build/archives`   \r\n\r\n* **archiveNameFormat** - `Groovy格式字符串`， 指定渠道打包输出的APK文件名格式，默认文件名格式是： `${appPkg}-${flavorName}-${buildType}-v${versionName}-${versionCode}`，可使用以下变量:  \r\n  \r\n  * *projectName* - 项目名字\r\n  * *appName* - App模块名字\r\n  * *appPkg* - `applicationId` (App包名packageName)\r\n  * *buildType* - `buildType` (release/debug/beta等)\r\n  * *flavorName* - `flavorName` (对应渠道打包中的渠道名字)\r\n  * *versionName* - `versionName` (显示用的版本号)\r\n  * *versionCode* - `versionCode` (内部版本号)\r\n  * *buildTime* - `buildTime` (编译构建日期时间)  \r\n\r\n### 命令行打包脚本\r\n\r\n如果不想使用Gradle插件，这里还有两个命令行打包脚本，在项目的 `tools` 目录里，分别是 `ngpacker-x.x.x-capsule.jar` 和 `ngpacker.py`，使用命令行打包工具，在Java代码里仍然是使用`packer-helper`包里的 `PackerNg.getMarket(Context)` 读取渠道\r\n\r\n#### Java脚本\r\n\r\n```shell\r\njava -jar ngpacker-x.x.x-capsule.jar release_apk_file market_file\r\n// help: java -jar packer-ng-x.x.x-capsule.jar\r\n```\r\n\r\n#### Python脚本\r\n\r\n```shell\r\npython ngpacker.py [file] [market] [output] [-h] [-s] [-t TEST]\r\n// help: python packer-ng.py -h\r\n// python; import ngpacker; help(ngpacker)\r\n```\r\n\r\n#### 不使用Gradle\r\n使用命令行打包脚本，不想添加Gradle依赖的，可以完全忽略Gradle的配置，直接复制 [PackerNg.java](helper/src/main/java/com/mcxiaoke/packer/helper/PackerNg.java) 到项目中使用即可\r\n\r\n## 实现原理\r\n\r\n### PackerNg原理\r\n\r\n#### 优点\r\n\r\n- 使用APK注释字段保存渠道信息和MAGIC字节，从文件末尾读取渠道信息，速度快\r\n- 实现为一个Gradle Plugin，支持定制输出APK的文件名等信息，方便CI集成\r\n- 提供Java版和Python的独立命令行脚本，不依赖Gradle插件，支持独立使用\r\n- 由于打包速度极快，单个包只需要5毫秒左右，可用于网站后台动态生成渠道包\r\n\r\n#### 缺点\r\n\r\n- 没有使用Android的productFlavors，无法利用flavors条件编译的功能\r\n\r\n### 文件格式\r\n\r\nAndroid应用使用的APK文件就是一个带签名信息的ZIP文件，根据 [ZIP文件格式规范](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT)，每个ZIP文件的最后都必须有一个叫 [Central Directory Record](https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html) 的部分，这个CDR的最后部分叫\"end of central directory record\"，这一部分包含一些元数据，它的末尾是ZIP文件的注释。注释包含**Comment Length**和**File Comment**两个字段，前者表示注释内容的长度，后者是注释的内容，正确修改这一部分不会对ZIP文件造成破坏，利用这个字段，我们可以添加一些自定义的数据，PackerNg项目就是在这里添加和读取渠道信息。\r\n\r\n### 细节处理\r\n\r\n原理很简单，就是将渠道信息存放在APK文件的注释字段中，但是实现起来遇到不少坑，测试了好多次。\r\n\r\n#### ZipOutputStream.setComment\r\n\r\n```java\r\n\r\nFileOutputStream is = new FileOutputStream(\"demo.apk\", true);\r\nZipOutputStream zos = new ZipOutputStream(is);\r\nzos.setComment(\"Google_Market\");\r\nzos.finish();\r\nzos.close();\r\n\r\nZipFile zipFile=new ZipFile(\"demo.apk\");\r\nSystem.out.println(zipFile.getComment());\r\n\r\n```\r\n使用Java写入APK文件注释虽然可以正常读取，但是安装的时候会失败，错误信息是：\r\n\r\n```shell\r\nadb install -r demo.apk\r\nFailure [INSTALL_FAILED_INVALID_APK]\r\n```\r\n\r\n原因未知，可能Java的Zip实现写入了某些特殊字符导致APK文件校验失败，于是只能放弃这个方法。同样的功能使用Python测试完全没有问题，处理后的APK可以正常安装。\r\n\r\n#### ZipFile.getComment\r\n\r\n上面是ZIP文件注释写入，使用Java会导致APK文件被破坏，无法安装。这里是读取ZIP文件注释的问题，Java 7里可以使用 `zipFile.getComment()` 方法直接读取注释，非常方便。但是Android系统直到API 19，也就是4.4以上的版本才支持 [`ZipFile.getComment()`](http://developer.android.com/intl/zh-cn/reference/java/util/zip/ZipFile.html#getComment()) 方法。由于要兼容之前的版本，所以这个方法也不能使用。\r\n\r\n#### 解决方法\r\n\r\n由于使用Java直接写入和读取ZIP文件的注释都不可行，使用Python又不方便与Gradle系统集成，所以只能自己实现注释的写入和读取。实现起来也不复杂，就是为了提高性能，避免读取整个文件，需要在注释的最后加入几个MAGIC字节，这样从文件的最后开始，读取很少的几个字节就可以定位渠道名的位置。\r\n\r\n几个常量定义：\r\n\r\n```java\r\n// ZIP文件的注释最长65535个字节\r\nstatic final int ZIP_COMMENT_MAX_LENGTH = 65535;\r\n// ZIP文件注释长度字段的字节数\r\nstatic final int SHORT_LENGTH = 2;\r\n// 文件最后用于定位的MAGIC字节\r\nstatic final byte[] MAGIC = new byte[]{0x21, 0x5a, 0x58, 0x4b, 0x21}; //!ZXK!\r\n\r\n```\r\n\r\n#### 读写注释\r\n\r\nJava版详细的实现见 [PackerNg.java](helper/src/main/java/com/mcxiaoke/packer/helper/PackerNg.java)，Python版的实现见 [ngpacker.py](tools/ngpacker.py) 。\r\n\r\n写入ZIP文件注释：\r\n\r\n```java\r\n\r\npublic static void writeZipComment(File file, String comment) \r\nthrows IOException {\r\n    byte[] data = comment.getBytes(UTF_8);\r\n    final RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\r\n    raf.seek(file.length() - SHORT_LENGTH);\r\n    // write zip comment length\r\n    // (content field length + length field length + magic field length)\r\n    writeShort(data.length + SHORT_LENGTH + MAGIC.length, raf);\r\n    // write content\r\n    writeBytes(data, raf);\r\n    // write content length\r\n    writeShort(data.length, raf);\r\n    // write magic bytes\r\n    writeBytes(MAGIC, raf);\r\n    raf.close();\r\n}\r\n\r\n```\r\n\r\n读取ZIP文件注释，有两个版本的实现，这里使用的是 `RandomAccessFile` ，另一个版本使用的是 `MappedByteBuffer` ，经过测试，对于特别长的注释，使用内存映射文件读取性能要稍微好一些，对于特别短的注释（比如渠道名），这个版本反而更快一些。\r\n\r\n```java\r\n\r\npublic static String readZipComment(File file) throws IOException {\r\n    RandomAccessFile raf = null;\r\n    try {\r\n        raf = new RandomAccessFile(file, \"r\");\r\n        long index = raf.length();\r\n        byte[] buffer = new byte[MAGIC.length];\r\n        index -= MAGIC.length;\r\n        // read magic bytes\r\n        raf.seek(index);\r\n        raf.readFully(buffer);\r\n        // if magic bytes matched\r\n        if (isMagicMatched(buffer)) {\r\n            index -= SHORT_LENGTH;\r\n            raf.seek(index);\r\n            // read content length field\r\n            int length = readShort(raf);\r\n            if (length > 0) {\r\n                index -= length;\r\n                raf.seek(index);\r\n                // read content bytes\r\n                byte[] bytesComment = new byte[length];\r\n                raf.readFully(bytesComment);\r\n                return new String(bytesComment, UTF_8);\r\n            }\r\n        }\r\n    } finally {\r\n        if (raf != null) {\r\n            raf.close();\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n```\r\n\r\n读取APK文件，由于这个库 `packer-helper` 需要同时给Gradle插件和Android项目使用，所以不能添加Android相关的依赖，但是又需要读取自身APK文件的路径，使用反射实现：\r\n\r\n```java\r\n\r\n// for android code\r\nprivate static String getSourceDir(final Object context)\r\n        throws ClassNotFoundException,\r\n        InvocationTargetException,\r\n        IllegalAccessException,\r\n        NoSuchFieldException,\r\n        NoSuchMethodException {\r\n    final Class<?> contextClass = Class.forName(\"android.content.Context\");\r\n    final Class<?> applicationInfoClass = Class.forName(\"android.content.pm.ApplicationInfo\");\r\n    final Method getApplicationInfoMethod = contextClass.getMethod(\"getApplicationInfo\");\r\n    final Object appInfo = getApplicationInfoMethod.invoke(context);\r\n    final Field sourceDirField = applicationInfoClass.getField(\"sourceDir\");\r\n    return (String) sourceDirField.get(appInfo);\r\n}\r\n\r\n```\r\n\r\n#### Gradle Plugin\r\n\r\n这个和旧版插件基本一致，首先是读取渠道列表文件，保存起来，打包的时候遍历列表，复制生成的APK文件到临时文件，给临时文件写入渠道信息，然后复制到输出目录，文件名可以使用模板定制。主要代码如下：\r\n\r\n```groovy\r\n// 添加打包用的TASK\r\ndef archiveTask = project.task(\"apk${variant.name.capitalize()}\",\r\n                type: ArchiveAllApkTask) {\r\n            theVariant = variant\r\n            theExtension = modifierExtension\r\n            theMarkets = markets\r\n            dependsOn variant.assemble\r\n        }\r\n        def buildTypeName = variant.buildType.name\r\n        if (variant.name != buildTypeName) {\r\n            project.task(\"apk${buildTypeName.capitalize()}\", dependsOn: archiveTask)\r\n        }\r\n\r\n\r\n// 遍历列表修改APK文件\r\ntheMarkets.each { String market ->\r\n            String apkName = buildApkName(theVariant, market)\r\n            File tempFile = new File(tempDir, apkName)\r\n            File finalFile = new File(outputDir, apkName)\r\n            tempFile << originalFile.bytes\r\n            copyTo(originalFile, tempFile)\r\n            PackerNg.Helper.writeMarket(tempFile, market)\r\n            if (PackerNg.Helper.verifyMarket(tempFile, market)) {\r\n                copyTo(tempFile, finalFile)\r\n            } \r\n        }\r\n\r\n```\r\n\r\n详细的实现可以查看文件 [PackerNgPlugin.groovy](plugin/src/main/groovy/com/mcxiaoke/packer/ng/PackerNgPlugin.groovy) 和文件 [ArchiveAllApkTask.groovy](plugin/src/main/groovy/com/mcxiaoke/packer/ng/ArchiveAllApkTask.groovy)\r\n\r\n### 同类工具\r\n\r\n- [**gradle-packer-plugin**](https://github.com/mcxiaoke/gradle-packer-plugin) - 旧版渠道打包工具，完全使用Gradle系统实现，能利用Android提供的productFlavors系统的条件编译功能，无任何兼容性问题，方便集成，但是由于每次都要重新打包，速度比较慢，不适合需要大量打包的情况。（性能：200个渠道包需要一到两小时）\r\n- [**Meituan-MultiChannelTool**](https://github.com/GavinCT/AndroidMultiChannelBuildTool) - 使用美团方案的实现，在APK文件的`META-INF`目里增加渠道文件，打包速度也非常快，但读取时需要遍历APK文件的数据项，比较慢，而且以后可能遇到兼容性问题\r\n- [**MultiChannelPackageTool**](https://github.com/seven456/MultiChannelPackageTool) - 将渠道写入APK文件的注释，这个项目没有提供Gradle插件，只有命令行工具，不方便CI集成，使用ZIP文件注释的思路就是来自此项目\r\n\r\n\r\n------\r\n\r\n## 关于作者\r\n\r\n#### 联系方式\r\n* Blog: <http://blog.mcxiaoke.com>\r\n* Github: <https://github.com/mcxiaoke>\r\n* Email: [github@mcxiaoke.com](mailto: github@mcxiaoke.com)\r\n\r\n#### 开源项目\r\n\r\n* Next公共组件库: <https://github.com/mcxiaoke/Android-Next>\r\n* Gradle渠道打包: <https://github.com/mcxiaoke/gradle-packer-plugin>\r\n* EventBus实现xBus: <https://github.com/mcxiaoke/xBus>\r\n* Rx文档中文翻译: <https://github.com/mcxiaoke/RxDocs>\r\n* MQTT协议中文版: <https://github.com/mcxiaoke/mqtt>\r\n* 蘑菇饭App: <https://github.com/mcxiaoke/minicat>\r\n* 饭否客户端: <https://github.com/mcxiaoke/fanfouapp-opensource>\r\n* Volley镜像: <https://github.com/mcxiaoke/android-volley>\r\n\r\n------\r\n\r\n## License\r\n\r\n    Copyright 2014, 2015, 2016 Xiaoke Zhang\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}