<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Packer-ng-plugin by mcxiaoke</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Packer-ng-plugin</h1>
      <h2 class="project-tagline">下一代Android打包工具，1000个渠道包只需要5秒钟</h2>
      <a href="https://github.com/mcxiaoke/packer-ng-plugin" class="btn">View on GitHub</a>
      <a href="https://github.com/mcxiaoke/packer-ng-plugin/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mcxiaoke/packer-ng-plugin/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="下一代android渠道打包工具" class="anchor" href="#%E4%B8%8B%E4%B8%80%E4%BB%A3android%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>下一代Android渠道打包工具</h1>

<h2>
<a id="最新版本" class="anchor" href="#%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>最新版本</h2>

<ul>
<li>
<strong>v1.0.4 - 2016.01.19</strong> - 完善获取APK路径的方法,增加MarketInfo</li>
<li>
<strong>v1.0.3 - 2016.01.14</strong> - 增加缓存，新增ResUtils，更有好的错误提示</li>
<li>
<strong>v1.0.2 - 2015.12.04</strong> - 兼容productFlavors，完善异常处理</li>
<li>
<strong>v1.0.1 - 2015.12.01</strong> - 如果没有读取到渠道，默认返回空字符串</li>
<li>
<strong>v1.0.0 - 2015.11.30</strong> - 增加Java和Python打包脚本，增加文档</li>
<li>
<strong>v0.9.9 - 2015.11.26</strong> - 测试版发布，支持全新的极速打包方式 </li>
</ul>

<h2>
<a id="项目介绍" class="anchor" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>项目介绍</h2>

<p><a href="https://github.com/mcxiaoke/packer-ng-plugin"><strong>packer-ng-plugin</strong></a> 是下一代Android渠道打包工具Gradle插件，支持极速打包，<strong>1000</strong>个渠道包只需要<strong>5</strong>秒钟，速度是 <a href="https://github.com/mcxiaoke/gradle-packer-plugin"><strong>gradle-packer-plugin</strong></a> 的<strong>1000</strong>倍以上，可方便的用于CI系统集成，支持自定义输出目录和最终APK文件名，依赖包： <code>com.mcxiaoke.gradle:packer-ng:1.0.+</code> 简短名：<code>packer</code>，可以在项目的 <code>build.gradle</code> 中指定使用，还提供了命令行独立使用的Java和Python脚本。实现原理见本文末尾。</p>

<h2>
<a id="使用指南" class="anchor" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>使用指南</h2>

<p><a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22packer-ng%22"><code>Maven Central</code></a></p>

<h3>
<a id="修改项目根目录的-buildgradle" class="anchor" href="#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84-buildgradle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>修改项目根目录的 <code>build.gradle</code>
</h3>

<div class="highlight highlight-source-groovy"><pre>
buildscript {
    <span class="pl-k">......</span>
    dependencies{
    <span class="pl-c">// add packer-ng</span>
        classpath <span class="pl-s"><span class="pl-pds">'</span>com.mcxiaoke.gradle:packer-ng:1.0.4<span class="pl-pds">'</span></span>
    }
}  </pre></div>

<h3>
<a id="修改android模块的-buildgradle" class="anchor" href="#%E4%BF%AE%E6%94%B9android%E6%A8%A1%E5%9D%97%E7%9A%84-buildgradle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>修改Android模块的 <code>build.gradle</code>
</h3>

<div class="highlight highlight-source-groovy"><pre>apply <span class="pl-c1">plugin</span>: <span class="pl-s"><span class="pl-pds">'</span>packer<span class="pl-pds">'</span></span> 

dependencies {
    <span class="pl-c">// add packer-helper</span>
    compile <span class="pl-s"><span class="pl-pds">'</span>com.mcxiaoke.gradle:packer-helper:1.0.4<span class="pl-pds">'</span></span>
} </pre></div>

<p><strong>注意：<code>packer-ng</code> 和 <code>packer-helper</code> 的版本号需要保持一致</strong></p>

<h3>
<a id="java代码中获取当前渠道" class="anchor" href="#java%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%B8%A0%E9%81%93" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Java代码中获取当前渠道</h3>

<p>提示：<code>PackerNg.getMarket(Context)</code>内部缓存了结果，不会重复解析APK文件</p>

<div class="highlight highlight-source-java"><pre>
<span class="pl-c">// 如果没有使用PackerNg打包添加渠道，默认返回的是""</span>
<span class="pl-c">// com.mcxiaoke.packer.helper.PackerNg</span>
<span class="pl-k">final</span> <span class="pl-smi">String</span> market <span class="pl-k">=</span> <span class="pl-smi">PackerNg</span><span class="pl-k">.</span>getMarket(<span class="pl-smi">Context</span>)
<span class="pl-c">// 或者使用 PackerNg.getMarket(Context,defaultValue)</span>
<span class="pl-c">// 之后就可以使用了，比如友盟可以这样设置</span>
<span class="pl-smi">AnalyticsConfig</span><span class="pl-k">.</span>setChannel(market)
</pre></div>

<h3>
<a id="渠道打包脚本" class="anchor" href="#%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>渠道打包脚本</h3>

<p>可以通过两种方式指定 <code>market</code> 属性，根据需要选用：</p>

<ul>
<li>打包时命令行使用 <code>-Pmarket= yourMarketFilePath</code> 指定属性</li>
<li>在 <code>gradle.properties</code> 里加入 <code>market=yourMarketFilePath</code>
</li>
</ul>

<p>market是你的渠道名列表文件，market文件是基于<strong>项目根目录</strong>的 <code>相对路径</code> ，假设你的项目位于 <code>~/github/myapp</code> 你的market文件位于 <code>~/github/myapp/config/markets.txt</code> 那么参数应该是 <code>-Pmarket=config/markets.txt</code>，一般建议直接放在项目根目录，如果market文件参数错误或者文件不存在会抛出异常。</p>

<p>渠道名列表文件是纯文本文件，每行一个渠道号，列表解析的时候会自动忽略空白行和格式不规范的行，请注意看命令行输出，渠道名和注释之间用 <code>#</code> 号分割开，可以没有注释，示例：</p>

<pre><code> Google_Play#play store market
 Gradle_Test#test
 SomeMarket#some market
 HelloWorld
</code></pre>

<p>渠道打包的Gradle命令行参数格式示例（在项目根目录执行）：  </p>

<div class="highlight highlight-source-shell"><pre>./gradlew -Pmarket=markets.txt clean apkRelease</pre></div>

<p>打包完成后你可以在 <code>${项目根目录}/build/archives/</code> 目录找到最终的渠道包。</p>

<h4>
<a id="任务说明" class="anchor" href="#%E4%BB%BB%E5%8A%A1%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>任务说明</h4>

<p>渠道打包的Gradle Task名字是 <code>apk${buildType}</code> buildType一般是release，也可以是你自己指定的beta或者someOtherType，使用时首字母需要大写，例如release的渠道包任务名是 <code>apkRelease</code>，beta的渠道包任务名是 <code>apkBeta</code>，其它的以此类推。</p>

<h4>
<a id="注意事项" class="anchor" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>注意事项</h4>

<p><strong>不支持<code>productFlavors</code>中定义的条件编译变量，不支持修改AndroidManifest</strong></p>

<p>如果你的项目有多个<code>productFlavors</code>，默认只会用第一个<code>flavor</code>生成的APK文件作为打包工具的输入参数，忽略其它<code>flavor</code>生成的apk，代码里用的是 <code>ariant.outputs[0].outputFile</code>。如果你想指定使用某个flavor来生成渠道包，可以用 <code>apkFlavor1Release</code>，<code>apkFlavor2Beta</code>这样的名字，示例（假设flavor名字是Intel）：</p>

<div class="highlight highlight-source-shell"><pre>./gradlew -Pmarket=markets.txt clean apkIntelRelease</pre></div>

<h3>
<a id="插件配置说明可选" class="anchor" href="#%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%E5%8F%AF%E9%80%89" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>插件配置说明（可选）</h3>

<div class="highlight highlight-source-groovy"><pre>packer {
    <span class="pl-c">// 指定渠道打包输出目录</span>
    <span class="pl-c">// archiveOutput = file(new File(project.rootProject.buildDir.path, "archives"))</span>
    <span class="pl-c">// 指定渠道打包输出文件名格式</span>
    <span class="pl-c">// 默认是 `${appPkg}-${flavorName}-${buildType}-v${versionName}-${versionCode}`</span>
    <span class="pl-c">// archiveNameFormat = ''</span>
}</pre></div>

<p>举例：假如你的App包名是  <code>com.your.company</code> ，渠道名是 <code>Google_Play</code> ，<code>buildType</code> 是 <code>release</code> ，<code>versionName</code> 是 <code>2.1.15</code> ，<code>versionCode</code> 是 <code>200115</code> ，那么生成的APK的文件名是 <code>com.your.company-Google_Player-release-2.1.15-20015.apk</code>   </p>

<ul>
<li><p><strong>archiveOutput</strong>  指定渠道打包输出的APK存放目录，默认位于<code>${项目根目录}/build/archives</code>   </p></li>
<li>
<p><strong>archiveNameFormat</strong> - <code>Groovy格式字符串</code>， 指定渠道打包输出的APK文件名格式，默认文件名格式是： <code>${appPkg}-${flavorName}-${buildType}-v${versionName}-${versionCode}</code>，可使用以下变量:  </p>

<ul>
<li>
<em>projectName</em> - 项目名字</li>
<li>
<em>appName</em> - App模块名字</li>
<li>
<em>appPkg</em> - <code>applicationId</code> (App包名packageName)</li>
<li>
<em>buildType</em> - <code>buildType</code> (release/debug/beta等)</li>
<li>
<em>flavorName</em> - <code>flavorName</code> (对应渠道打包中的渠道名字)</li>
<li>
<em>versionName</em> - <code>versionName</code> (显示用的版本号)</li>
<li>
<em>versionCode</em> - <code>versionCode</code> (内部版本号)</li>
<li>
<em>buildTime</em> - <code>buildTime</code> (编译构建日期时间)<br>
</li>
</ul>
</li>
</ul>

<h3>
<a id="命令行打包脚本" class="anchor" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>命令行打包脚本</h3>

<p>如果不想使用Gradle插件，这里还有两个命令行打包脚本，在项目的 <code>tools</code> 目录里，分别是 <code>ngpacker-x.x.x-capsule.jar</code> 和 <code>ngpacker.py</code>，使用命令行打包工具，在Java代码里仍然是使用<code>packer-helper</code>包里的 <code>PackerNg.getMarket(Context)</code> 读取渠道</p>

<h4>
<a id="java脚本" class="anchor" href="#java%E8%84%9A%E6%9C%AC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Java脚本</h4>

<div class="highlight highlight-source-shell"><pre>java -jar ngpacker-x.x.x-capsule.jar release_apk_file market_file
// <span class="pl-c1">help</span>: java -jar packer-ng-x.x.x-capsule.jar</pre></div>

<h4>
<a id="python脚本" class="anchor" href="#python%E8%84%9A%E6%9C%AC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Python脚本</h4>

<div class="highlight highlight-source-shell"><pre>python ngpacker.py [file] [market] [output] [-h] [-s] [-t TEST]
// <span class="pl-c1">help</span>: python packer-ng.py -h
// python<span class="pl-k">;</span> import ngpacker<span class="pl-k">;</span> <span class="pl-c1">help</span>(ngpacker)</pre></div>

<h4>
<a id="不使用gradle" class="anchor" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8gradle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>不使用Gradle</h4>

<p>使用命令行打包脚本，不想添加Gradle依赖的，可以完全忽略Gradle的配置，直接复制 <a href="helper/src/main/java/com/mcxiaoke/packer/helper/PackerNg.java">PackerNg.java</a> 到项目中使用即可</p>

<h2>
<a id="实现原理" class="anchor" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>实现原理</h2>

<h3>
<a id="packerng原理" class="anchor" href="#packerng%E5%8E%9F%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PackerNg原理</h3>

<h4>
<a id="优点" class="anchor" href="#%E4%BC%98%E7%82%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>优点</h4>

<ul>
<li>使用APK注释字段保存渠道信息和MAGIC字节，从文件末尾读取渠道信息，速度快</li>
<li>实现为一个Gradle Plugin，支持定制输出APK的文件名等信息，方便CI集成</li>
<li>提供Java版和Python的独立命令行脚本，不依赖Gradle插件，支持独立使用</li>
<li>由于打包速度极快，单个包只需要5毫秒左右，可用于网站后台动态生成渠道包</li>
</ul>

<h4>
<a id="缺点" class="anchor" href="#%E7%BC%BA%E7%82%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>缺点</h4>

<ul>
<li>没有使用Android的productFlavors，无法利用flavors条件编译的功能</li>
</ul>

<h3>
<a id="文件格式" class="anchor" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>文件格式</h3>

<p>Android应用使用的APK文件就是一个带签名信息的ZIP文件，根据 <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">ZIP文件格式规范</a>，每个ZIP文件的最后都必须有一个叫 <a href="https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html">Central Directory Record</a> 的部分，这个CDR的最后部分叫"end of central directory record"，这一部分包含一些元数据，它的末尾是ZIP文件的注释。注释包含<strong>Comment Length</strong>和<strong>File Comment</strong>两个字段，前者表示注释内容的长度，后者是注释的内容，正确修改这一部分不会对ZIP文件造成破坏，利用这个字段，我们可以添加一些自定义的数据，PackerNg项目就是在这里添加和读取渠道信息。</p>

<h3>
<a id="细节处理" class="anchor" href="#%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>细节处理</h3>

<p>原理很简单，就是将渠道信息存放在APK文件的注释字段中，但是实现起来遇到不少坑，测试了好多次。</p>

<h4>
<a id="zipoutputstreamsetcomment" class="anchor" href="#zipoutputstreamsetcomment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ZipOutputStream.setComment</h4>

<div class="highlight highlight-source-java"><pre>
<span class="pl-smi">FileOutputStream</span> is <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">FileOutputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>demo.apk<span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>);
<span class="pl-smi">ZipOutputStream</span> zos <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ZipOutputStream</span>(is);
zos<span class="pl-k">.</span>setComment(<span class="pl-s"><span class="pl-pds">"</span>Google_Market<span class="pl-pds">"</span></span>);
zos<span class="pl-k">.</span>finish();
zos<span class="pl-k">.</span>close();

<span class="pl-smi">ZipFile</span> zipFile<span class="pl-k">=</span><span class="pl-k">new</span> <span class="pl-smi">ZipFile</span>(<span class="pl-s"><span class="pl-pds">"</span>demo.apk<span class="pl-pds">"</span></span>);
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(zipFile<span class="pl-k">.</span>getComment());
</pre></div>

<p>使用Java写入APK文件注释虽然可以正常读取，但是安装的时候会失败，错误信息是：</p>

<div class="highlight highlight-source-shell"><pre>adb install -r demo.apk
Failure [INSTALL_FAILED_INVALID_APK]</pre></div>

<p>原因未知，可能Java的Zip实现写入了某些特殊字符导致APK文件校验失败，于是只能放弃这个方法。同样的功能使用Python测试完全没有问题，处理后的APK可以正常安装。</p>

<h4>
<a id="zipfilegetcomment" class="anchor" href="#zipfilegetcomment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ZipFile.getComment</h4>

<p>上面是ZIP文件注释写入，使用Java会导致APK文件被破坏，无法安装。这里是读取ZIP文件注释的问题，Java 7里可以使用 <code>zipFile.getComment()</code> 方法直接读取注释，非常方便。但是Android系统直到API 19，也就是4.4以上的版本才支持 <a href="http://developer.android.com/intl/zh-cn/reference/java/util/zip/ZipFile.html#getComment()"><code>ZipFile.getComment()</code></a> 方法。由于要兼容之前的版本，所以这个方法也不能使用。</p>

<h4>
<a id="解决方法" class="anchor" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>解决方法</h4>

<p>由于使用Java直接写入和读取ZIP文件的注释都不可行，使用Python又不方便与Gradle系统集成，所以只能自己实现注释的写入和读取。实现起来也不复杂，就是为了提高性能，避免读取整个文件，需要在注释的最后加入几个MAGIC字节，这样从文件的最后开始，读取很少的几个字节就可以定位渠道名的位置。</p>

<p>几个常量定义：</p>

<div class="highlight highlight-source-java"><pre><span class="pl-c">// ZIP文件的注释最长65535个字节</span>
<span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">int</span> <span class="pl-c1">ZIP_COMMENT_MAX_LENGTH</span> <span class="pl-k">=</span> <span class="pl-c1">65535</span>;
<span class="pl-c">// ZIP文件注释长度字段的字节数</span>
<span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">int</span> <span class="pl-c1">SHORT_LENGTH</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>;
<span class="pl-c">// 文件最后用于定位的MAGIC字节</span>
<span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">byte</span>[] <span class="pl-c1">MAGIC</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">byte</span>[]{0x21, 0x5a, 0x58, 0x4b, 0x21}; <span class="pl-c">//!ZXK!</span>
</pre></div>

<h4>
<a id="读写注释" class="anchor" href="#%E8%AF%BB%E5%86%99%E6%B3%A8%E9%87%8A" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>读写注释</h4>

<p>Java版详细的实现见 <a href="helper/src/main/java/com/mcxiaoke/packer/helper/PackerNg.java">PackerNg.java</a>，Python版的实现见 <a href="tools/ngpacker.py">ngpacker.py</a> 。</p>

<p>写入ZIP文件注释：</p>

<div class="highlight highlight-source-java"><pre>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> writeZipComment(<span class="pl-smi">File</span> file, <span class="pl-smi">String</span> comment) 
throws <span class="pl-smi">IOException</span> {
    <span class="pl-k">byte</span>[] data <span class="pl-k">=</span> comment<span class="pl-k">.</span>getBytes(<span class="pl-c1">UTF_8</span>);
    <span class="pl-k">final</span> <span class="pl-smi">RandomAccessFile</span> raf <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">RandomAccessFile</span>(file, <span class="pl-s"><span class="pl-pds">"</span>rw<span class="pl-pds">"</span></span>);
    raf<span class="pl-k">.</span>seek(file<span class="pl-k">.</span>length() <span class="pl-k">-</span> <span class="pl-c1">SHORT_LENGTH</span>);
    <span class="pl-c">// write zip comment length</span>
    <span class="pl-c">// (content field length + length field length + magic field length)</span>
    writeShort(data<span class="pl-k">.</span>length <span class="pl-k">+</span> <span class="pl-c1">SHORT_LENGTH</span> <span class="pl-k">+</span> <span class="pl-c1">MAGIC</span><span class="pl-k">.</span>length, raf);
    <span class="pl-c">// write content</span>
    writeBytes(data, raf);
    <span class="pl-c">// write content length</span>
    writeShort(data<span class="pl-k">.</span>length, raf);
    <span class="pl-c">// write magic bytes</span>
    writeBytes(<span class="pl-c1">MAGIC</span>, raf);
    raf<span class="pl-k">.</span>close();
}
</pre></div>

<p>读取ZIP文件注释，有两个版本的实现，这里使用的是 <code>RandomAccessFile</code> ，另一个版本使用的是 <code>MappedByteBuffer</code> ，经过测试，对于特别长的注释，使用内存映射文件读取性能要稍微好一些，对于特别短的注释（比如渠道名），这个版本反而更快一些。</p>

<div class="highlight highlight-source-java"><pre>
<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> readZipComment(<span class="pl-smi">File</span> file) throws <span class="pl-smi">IOException</span> {
    <span class="pl-smi">RandomAccessFile</span> raf <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    <span class="pl-k">try</span> {
        raf <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">RandomAccessFile</span>(file, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
        <span class="pl-k">long</span> index <span class="pl-k">=</span> raf<span class="pl-k">.</span>length();
        <span class="pl-k">byte</span>[] buffer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">byte</span>[<span class="pl-c1">MAGIC</span><span class="pl-k">.</span>length];
        index <span class="pl-k">-=</span> <span class="pl-c1">MAGIC</span><span class="pl-k">.</span>length;
        <span class="pl-c">// read magic bytes</span>
        raf<span class="pl-k">.</span>seek(index);
        raf<span class="pl-k">.</span>readFully(buffer);
        <span class="pl-c">// if magic bytes matched</span>
        <span class="pl-k">if</span> (isMagicMatched(buffer)) {
            index <span class="pl-k">-=</span> <span class="pl-c1">SHORT_LENGTH</span>;
            raf<span class="pl-k">.</span>seek(index);
            <span class="pl-c">// read content length field</span>
            <span class="pl-k">int</span> length <span class="pl-k">=</span> readShort(raf);
            <span class="pl-k">if</span> (length <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                index <span class="pl-k">-=</span> length;
                raf<span class="pl-k">.</span>seek(index);
                <span class="pl-c">// read content bytes</span>
                <span class="pl-k">byte</span>[] bytesComment <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">byte</span>[length];
                raf<span class="pl-k">.</span>readFully(bytesComment);
                <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(bytesComment, <span class="pl-c1">UTF_8</span>);
            }
        }
    } <span class="pl-k">finally</span> {
        <span class="pl-k">if</span> (raf <span class="pl-k">!=</span> <span class="pl-c1">null</span>) {
            raf<span class="pl-k">.</span>close();
        }
    }
    <span class="pl-k">return</span> <span class="pl-c1">null</span>;
}
</pre></div>

<p>读取APK文件，由于这个库 <code>packer-helper</code> 需要同时给Gradle插件和Android项目使用，所以不能添加Android相关的依赖，但是又需要读取自身APK文件的路径，使用反射实现：</p>

<div class="highlight highlight-source-java"><pre>
<span class="pl-c">// for android code</span>
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> getSourceDir(<span class="pl-k">final</span> <span class="pl-smi">Object</span> context)
        throws <span class="pl-smi">ClassNotFoundException</span>,
        <span class="pl-smi">InvocationTargetException</span>,
        <span class="pl-smi">IllegalAccessException</span>,
        <span class="pl-smi">NoSuchFieldException</span>,
        <span class="pl-smi">NoSuchMethodException</span> {
    <span class="pl-k">final</span> <span class="pl-k">Class&lt;?&gt;</span> contextClass <span class="pl-k">=</span> <span class="pl-smi">Class</span><span class="pl-k">.</span>forName(<span class="pl-s"><span class="pl-pds">"</span>android.content.Context<span class="pl-pds">"</span></span>);
    <span class="pl-k">final</span> <span class="pl-k">Class&lt;?&gt;</span> applicationInfoClass <span class="pl-k">=</span> <span class="pl-smi">Class</span><span class="pl-k">.</span>forName(<span class="pl-s"><span class="pl-pds">"</span>android.content.pm.ApplicationInfo<span class="pl-pds">"</span></span>);
    <span class="pl-k">final</span> <span class="pl-smi">Method</span> getApplicationInfoMethod <span class="pl-k">=</span> contextClass<span class="pl-k">.</span>getMethod(<span class="pl-s"><span class="pl-pds">"</span>getApplicationInfo<span class="pl-pds">"</span></span>);
    <span class="pl-k">final</span> <span class="pl-smi">Object</span> appInfo <span class="pl-k">=</span> getApplicationInfoMethod<span class="pl-k">.</span>invoke(context);
    <span class="pl-k">final</span> <span class="pl-smi">Field</span> sourceDirField <span class="pl-k">=</span> applicationInfoClass<span class="pl-k">.</span>getField(<span class="pl-s"><span class="pl-pds">"</span>sourceDir<span class="pl-pds">"</span></span>);
    <span class="pl-k">return</span> (<span class="pl-smi">String</span>) sourceDirField<span class="pl-k">.</span>get(appInfo);
}
</pre></div>

<h4>
<a id="gradle-plugin" class="anchor" href="#gradle-plugin" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Gradle Plugin</h4>

<p>这个和旧版插件基本一致，首先是读取渠道列表文件，保存起来，打包的时候遍历列表，复制生成的APK文件到临时文件，给临时文件写入渠道信息，然后复制到输出目录，文件名可以使用模板定制。主要代码如下：</p>

<div class="highlight highlight-source-groovy"><pre><span class="pl-c">// 添加打包用的TASK</span>
<span class="pl-k">def</span> archiveTask <span class="pl-k">=</span> project<span class="pl-k">.</span>task(<span class="pl-s"><span class="pl-pds">"</span>apk<span class="pl-s1"><span class="pl-pse">${</span>variant.name.capitalize()<span class="pl-pse">}</span></span><span class="pl-pds">"</span></span>,
                <span class="pl-c1">type</span>: <span class="pl-k">ArchiveAllApkTask</span>) {
            theVariant <span class="pl-k">=</span> variant
            theExtension <span class="pl-k">=</span> modifierExtension
            theMarkets <span class="pl-k">=</span> markets
            dependsOn variant<span class="pl-k">.</span>assemble
        }
        <span class="pl-k">def</span> buildTypeName <span class="pl-k">=</span> variant<span class="pl-k">.</span>buildType<span class="pl-k">.</span>name
        <span class="pl-k">if</span> (variant<span class="pl-k">.</span>name <span class="pl-k">!=</span> buildTypeName) {
            project<span class="pl-k">.</span>task(<span class="pl-s"><span class="pl-pds">"</span>apk<span class="pl-s1"><span class="pl-pse">${</span>buildTypeName.capitalize()<span class="pl-pse">}</span></span><span class="pl-pds">"</span></span>, <span class="pl-c1">dependsOn</span>: archiveTask)
        }


<span class="pl-c">// 遍历列表修改APK文件</span>
theMarkets<span class="pl-k">.</span>each { <span class="pl-k">String</span> <span class="pl-v">market</span> <span class="pl-k">-&gt;</span>
            <span class="pl-k">String</span> apkName <span class="pl-k">=</span> buildApkName(theVariant, market)
            <span class="pl-k">File</span> tempFile <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">File</span>(tempDir, apkName)
            <span class="pl-k">File</span> finalFile <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">File</span>(outputDir, apkName)
            tempFile <span class="pl-k">&lt;&lt;</span> originalFile<span class="pl-k">.</span>bytes
            copyTo(originalFile, tempFile)
            <span class="pl-k">PackerNg.Helper</span><span class="pl-k">.</span>writeMarket(tempFile, market)
            <span class="pl-k">if</span> (<span class="pl-k">PackerNg.Helper</span><span class="pl-k">.</span>verifyMarket(tempFile, market)) {
                copyTo(tempFile, finalFile)
            } 
        }
</pre></div>

<p>详细的实现可以查看文件 <a href="plugin/src/main/groovy/com/mcxiaoke/packer/ng/PackerNgPlugin.groovy">PackerNgPlugin.groovy</a> 和文件 <a href="plugin/src/main/groovy/com/mcxiaoke/packer/ng/ArchiveAllApkTask.groovy">ArchiveAllApkTask.groovy</a></p>

<h3>
<a id="同类工具" class="anchor" href="#%E5%90%8C%E7%B1%BB%E5%B7%A5%E5%85%B7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>同类工具</h3>

<ul>
<li>
<a href="https://github.com/mcxiaoke/gradle-packer-plugin"><strong>gradle-packer-plugin</strong></a> - 旧版渠道打包工具，完全使用Gradle系统实现，能利用Android提供的productFlavors系统的条件编译功能，无任何兼容性问题，方便集成，但是由于每次都要重新打包，速度比较慢，不适合需要大量打包的情况。（性能：200个渠道包需要一到两小时）</li>
<li>
<a href="https://github.com/GavinCT/AndroidMultiChannelBuildTool"><strong>Meituan-MultiChannelTool</strong></a> - 使用美团方案的实现，在APK文件的<code>META-INF</code>目里增加渠道文件，打包速度也非常快，但读取时需要遍历APK文件的数据项，比较慢，而且以后可能遇到兼容性问题</li>
<li>
<a href="https://github.com/seven456/MultiChannelPackageTool"><strong>MultiChannelPackageTool</strong></a> - 将渠道写入APK文件的注释，这个项目没有提供Gradle插件，只有命令行工具，不方便CI集成，使用ZIP文件注释的思路就是来自此项目</li>
</ul>

<hr>

<h2>
<a id="关于作者" class="anchor" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>关于作者</h2>

<h4>
<a id="联系方式" class="anchor" href="#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>联系方式</h4>

<ul>
<li>Blog: <a href="http://blog.mcxiaoke.com">http://blog.mcxiaoke.com</a>
</li>
<li>Github: <a href="https://github.com/mcxiaoke">https://github.com/mcxiaoke</a>
</li>
<li>Email: <a href="mailto:%20github@mcxiaoke.com">github@mcxiaoke.com</a>
</li>
</ul>

<h4>
<a id="开源项目" class="anchor" href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>开源项目</h4>

<ul>
<li>Next公共组件库: <a href="https://github.com/mcxiaoke/Android-Next">https://github.com/mcxiaoke/Android-Next</a>
</li>
<li>Gradle渠道打包: <a href="https://github.com/mcxiaoke/gradle-packer-plugin">https://github.com/mcxiaoke/gradle-packer-plugin</a>
</li>
<li>EventBus实现xBus: <a href="https://github.com/mcxiaoke/xBus">https://github.com/mcxiaoke/xBus</a>
</li>
<li>Rx文档中文翻译: <a href="https://github.com/mcxiaoke/RxDocs">https://github.com/mcxiaoke/RxDocs</a>
</li>
<li>MQTT协议中文版: <a href="https://github.com/mcxiaoke/mqtt">https://github.com/mcxiaoke/mqtt</a>
</li>
<li>蘑菇饭App: <a href="https://github.com/mcxiaoke/minicat">https://github.com/mcxiaoke/minicat</a>
</li>
<li>饭否客户端: <a href="https://github.com/mcxiaoke/fanfouapp-opensource">https://github.com/mcxiaoke/fanfouapp-opensource</a>
</li>
<li>Volley镜像: <a href="https://github.com/mcxiaoke/android-volley">https://github.com/mcxiaoke/android-volley</a>
</li>
</ul>

<hr>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<pre><code>Copyright 2014, 2015, 2016 Xiaoke Zhang

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mcxiaoke/packer-ng-plugin">Packer-ng-plugin</a> is maintained by <a href="https://github.com/mcxiaoke">mcxiaoke</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
